import { SgTableComponent } from '../table.component';
import { SgTableSorter } from '../../data-source';

export type META_COLUMN_TYPES = 'header' | 'headerGroup' | 'footer';
export type COLUMN_TYPES = META_COLUMN_TYPES | 'table';

export interface SgTableMetaCellTemplateContext<T> {
  col: SgColumnDefinition;
  table: SgTableComponent<T>;
}

export interface SgTableCellTemplateContext<T> {
  $implicit: SgTableCellTemplateContext<T>;
  row: T,
  col: SgColumnDefinition,
  value: any
}

export interface SgClolumnTypeDefinition {
  /**
   * The type of the values in this column.
   * This is an additional level for matching columns to templates, grouping templates for a type.
   */
  type: string;
  /**
   * Optional value to be used by the template when rendering the cell.
   * Any value is allowed, including functions which allow complex scenarions, for exapmle rendering a cell based on values from other cells.
   */
  typeData?: any;
}

export interface SgBaseColumnDefinition extends Partial<SgClolumnTypeDefinition> {
  /**
   * A Unique ID for the column.
   * The ID must be unique across all columns, regardless of the type.
   * Columns with identical ID will share result in identical template.
   *
   * For example, having a header column and a footer column with the same id will result in the same cell presentation for both.
   *
   * > The ID is mandatory. Some implementation might use other values to auto-generate it and some might require it explicilty.
   * This is what it is optional.
   */
  id?: string;
  label?: string;

  /**
   * The type of the values in this column.
   * This is an additional level for matching columns to templates, grouping templates for a type.
   */
  type?: string;
  /**
   * Optional value to be used by the template when rendering the cell.
   * Any value is allowed, including functions which allow complex scenarions, for exapmle rendering a cell based on values from other cells.
   */
  typeData?: any;

  /**
   * CSS class that get applied on the header and cell.
   * You can apply unique header/cell styles using the element name.
   */
  css?: string;

  /**
   * The width in px or % in the following format: ##% or ##px
   * Examples: '50%', '50px'
   */
  width?: string;
  minWidth?: number;
}

export interface SgMetaColumnDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   */
  id: string;

  kind: 'header' | 'footer';

  /**
   * The index (zero based) of the header row this column is attached to, used for multi-header setup.
   * When not set (undefined) the index is considered the LAST index.
   */
  rowIndex: number;
}

export interface SgColumnGroupDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   * Auto-generated from the property
   */
  id?: string;

   /**
   * The index (zero based) of the header row this header group column is attached to, used for multi-header setup.
   */
  rowIndex: number;
  prop: string;
  span: number;
}

export interface SgColumnDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   * Whe not set (recommaned) it is auto-generated by concatenating the values of `prop` and ,
   * If you set this value manually, make sure it does not conflict with other columns!
   */
  id?: string;


  /**
   * The property to display (from the row element)
   * You can use dot notation to display deep paths.
   */
  prop: string;

  headerType?: SgClolumnTypeDefinition;
  footerType?: SgClolumnTypeDefinition;

  /**
   * A path to a nested object, relative to the row element.
   * The table will display `prop` from the object referenced by `path`.
   *
   * You can also use dot notation directly from `prop`.
   *
   * Example:
   * prop: "street"
   * path: [ "myInstance", "user", "address"
   *
   * is identical to:
   * prop: "myInstance.user.address.street"
   *
   */
  path?: string[];

  sort?: boolean | SgTableSorter;
}

export type COLUMN_DEF = SgMetaColumnDefinition | SgColumnDefinition | SgColumnGroupDefinition;
