import { SgTableComponent } from '../table.component';
import { SgTableSorter } from '../../data-source/types';
import { SgMetaColumn } from './meta-column';
import { SgColumn } from './column';
import { SgColumnGroup } from './group-column';

export type META_COLUMN_TYPES = 'header' | 'headerGroup' | 'footer';
export type COLUMN_TYPES = META_COLUMN_TYPES | 'table';

export interface SgTableMetaCellTemplateContext<T> {
  $implicit: SgTableMetaCellTemplateContext<T>;
  col: SgMetaColumn;
  table: SgTableComponent<T>;
}

export interface SgTableCellTemplateContext<T = any, P extends keyof SgColumnTypeDefinitionDataMap = keyof SgColumnTypeDefinitionDataMap> {
  $implicit: SgTableCellTemplateContext<T>;
  row: T,
  value: any;
  col: SgColumn;
  table: SgTableComponent<T>;
}

export interface SgColumnTypeDefinitionDataMap {
  [typeName: string]: any;
}

export type SgColumnTypeDefinition<P extends keyof SgColumnTypeDefinitionDataMap = any> = { name: P; data?: SgColumnTypeDefinitionDataMap[P] };

  /**
   * The type of the values in this column.
   * This is an additional level for matching columns to templates, grouping templates for a type.
   */
  // type: string | ;
  /**
   * Optional value to be used by the template when rendering the cell.
   * Any value is allowed, including functions which allow complex scenarios, for example rendering a cell based on values from other cells.
   */
  // typeData?: any;

export interface SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   * The ID must be unique across all columns, regardless of the type.
   * Columns with identical ID will share result in identical template.
   *
   * For example, having a header column and a footer column with the same id will result in the same cell presentation for both.
   *
   * > The ID is mandatory. Some implementation might use other values to auto-generate it and some might require it explicitly.
   * This is what it is optional.
   */
  id?: string;
  label?: string;

  /**
   * The type of the values in this column.
   * This is an additional level for matching columns to templates, grouping templates for a type.
   */
  type?: string | SgColumnTypeDefinition;

  /**
   * CSS class that get applied on the header and cell.
   * You can apply unique header/cell styles using the element name.
   */
  css?: string;

  /**
   * The width in px or % in the following format: ##% or ##px
   * Examples: '50%', '50px'
   */
  width?: string;
  minWidth?: number;

  /**
   * A place to store things...
   * This must be an object, values are shadow-copied so persist data between multiple plugins.
   */
  data?: any;
}

export interface SgMetaColumnDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   */
  id: string;

  kind: 'header' | 'footer';

  /**
   * The index (zero based) of the header row this column is attached to, used for multi-header setup.
   * When not set (undefined) the index is considered the LAST index.
   */
  rowIndex: number;
}

export interface SgColumnGroupDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   * Auto-generated from the property
   */
  id?: string;

   /**
   * The index (zero based) of the header row this header group column is attached to, used for multi-header setup.
   */
  rowIndex: number;
  prop: string;
  span: number;
}

export interface SgColumnDefinition extends SgBaseColumnDefinition {
  /**
   * A Unique ID for the column.
   * Whe not set (recommend) it is auto-generated by concatenating the values of `prop` and ,
   * If you set this value manually, make sure it does not conflict with other columns!
   */
  id?: string;


  /**
   * The property to display (from the row element)
   * You can use dot notation to display deep paths.
   */
  prop: string;

  headerType?: string | SgColumnTypeDefinition;
  footerType?: string | SgColumnTypeDefinition;

  /**
   * A path to a nested object, relative to the row element.
   * The table will display `prop` from the object referenced by `path`.
   *
   * You can also use dot notation directly from `prop`.
   *
   * Example:
   * prop: "street"
   * path: [ "myInstance", "user", "address"
   *
   * is identical to:
   * prop: "myInstance.user.address.street"
   *
   */
  path?: string[];

  sort?: boolean | SgTableSorter;
}

/**
 * Represent a list of meta column's that together form a META ROW.
 * In other words, this is the definition of a row, using it's building blocks - the columns.
 *
 * > A row in the table represents a row in the datasource, A **meta row** does not, it can represent anything.
 * Meta rows are header, footer and header group.
 */
export interface SgColumnSet<T extends SgMetaColumnDefinition | SgColumnGroupDefinition> {
  rowIndex: number;
  cols: T[];
  rowClassName?: string;
}

/**
 * Represent a complete column definition set for a table. (table, header, footer and headerGroup columns).
 *
 * `SgTableColumnDefinitionSet` contains POJO objects (simple JSON like objects) for each column type (`SgColumnDefinition`, `SgMetaColumnDefinition` and `SgColumnGroupDefinition`)
 * which are later used to create runtime instance for each column type (`SgColumn`, `SgMetaColumn` and `SgColumnGroup`)
 *
 * Because `SgTableColumnDefinitionSet` contains POJO objects it can be serialized easily.
 */
export interface SgTableColumnDefinitionSet {
  table: SgColumnDefinition[];
  header: SgColumnSet<SgMetaColumnDefinition>[];
  footer: SgColumnSet<SgMetaColumnDefinition>[];
  headerGroup: SgColumnSet<SgColumnGroupDefinition>[];
}

/**
 * Represent a complete column set for a table. (table, header, footer and headerGroup columns).
 *
 * `SgTableColumnSet` contains runtime instances of for each column type (`SgColumn`, `SgMetaColumn` and `SgColumnGroup`)
 * which
 */
export interface SgTableColumnSet {
  table: SgColumn[];
  header: SgColumnSet<SgMetaColumn>[];
  footer: SgColumnSet<SgMetaColumn>[];
  headerGroup: SgColumnSet<SgColumnGroup>[];
}
